name: ICS Import
on:
  schedule:
    - cron: '0 * * * *'   # hourly
  workflow_dispatch: {}
jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Import iCal feeds
        env:
          SUPABASE_URL: https://dkyzbzlshrxdwetykmdo.supabase.co
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node - <<'EOF'
          const SUPABASE_URL = process.env.SUPABASE_URL;
          const KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
          if (!SUPABASE_URL || !KEY) { console.error('Missing env'); process.exit(1); }

          const headers = { apikey: KEY, Authorization: `Bearer ${KEY}` };

          async function get(path, query='') {
            const r = await fetch(`${SUPABASE_URL}/rest/v1/${path}${query}`, { headers });
            if (!r.ok) throw new Error(`${path} ${r.status} ${await r.text()}`);
            return r.json();
          }
          async function patch(path, body, filter) {
            const r = await fetch(`${SUPABASE_URL}/rest/v1/${path}?${filter}`, {
              method:'PATCH',
              headers:{...headers,'Content-Type':'application/json','Prefer':'return=minimal'},
              body:JSON.stringify(body)
            });
            if (!r.ok) throw new Error(`PATCH ${path} ${r.status} ${await r.text()}`);
          }
          async function post(path, body, query='') {
            const r = await fetch(`${SUPABASE_URL}/rest/v1/${path}${query}`, {
              method:'POST',
              headers:{...headers,'Content-Type':'application/json','Prefer':'return=minimal'},
              body:JSON.stringify(body)
            });
            if (!r.ok && r.status !== 409) throw new Error(`POST ${path} ${r.status} ${await r.text()}`);
          }

          function unfold(ics) { return ics.replace(/\\r?\\n[ \\t]/g,''); }
          function parse(ics) {
            const lines = unfold(ics).split(/\\r?\\n/);
            const events=[]; let cur=null;
            for (const line of lines) {
              if (line==='BEGIN:VEVENT') cur={};
              else if (line==='END:VEVENT') { if (cur?.DTSTART && cur?.DTEND) events.push(cur); cur=null; }
              else if (/^DTSTART/.test(line)) cur.DTSTART=line.split(':')[1];
              else if (/^DTEND/.test(line)) cur.DTEND=line.split(':')[1];
              else if (/^SUMMARY:/.test(line)) cur.SUMMARY=line.substring(8).trim();
            }
            return events;
          }
          function toTs(v){
            if (!v) return null;
            if (/^\\d{8}$/.test(v)) return `${v.slice(0,4)}-${v.slice(4,6)}-${v.slice(6,8)}T00:00:00Z`;
            return /Z$/.test(v)?v:v+'Z';
          }
          function guest(summary){
            if(!summary) return {first:null,last:null};
            summary = summary.replace(/^Reservation:\\s*/i,'').trim();
            const parts = summary.split(/\\s+/);
            if (parts.length===1) return {first:parts[0],last:null};
            return {first:parts[0],last:parts.slice(1).join(' ')};
          }

          (async () => {
            const feeds = await get('ical_feeds','?select=id,org_id,property_id,platform,feed_url&is_active=eq.true');
            const props = await get('properties','?select=id,name');
            const propName = Object.fromEntries(props.map(p=>[p.id,p.name]));
            const rows=[];

            for (const f of feeds) {
              try {
                const rf = await fetch(f.feed_url);
                if(!rf.ok){ console.warn('Fetch fail', f.id, rf.status); continue; }
                const events = parse(await rf.text());
                for (const ev of events) {
                  const ci = toTs(ev.DTSTART);
                  const co = toTs(ev.DTEND);
                  if(!ci || !co) continue;
                  const g = guest(ev.SUMMARY);
                  rows.push({
                    org_id: f.org_id,
                    property_id: f.property_id,
                    property_name: propName[f.property_id] || null,
                    platform: f.platform,
                    guest_first_name: g.first,
                    guest_last_name: g.last,
                    check_in: ci,
                    check_out: co,
                    status: 'confirmed',
                    currency: 'ZAR'
                  });
                }
                // Update feed timestamp
                await patch('ical_feeds', { last_import_at: new Date().toISOString() }, `id=eq.${f.id}`);
              } catch(e) {
                console.error('Feed error', f.id, e.message);
              }
            }

            // Deduplicate
            const map=new Map();
            for (const r of rows) {
              const k=`${r.property_id}|${r.platform}|${r.check_in}|${r.check_out}`;
              if(!map.has(k)) map.set(k,r);
            }
            const finalRows=[...map.values()];

            // Batch upsert
            for(let i=0;i<finalRows.length;i+=300){
              await post('bookings', finalRows.slice(i,i+300), '?on_conflict=org_id,property_id,platform,check_in,check_out');
            }

            // Soft removal marking
            const nowIso = new Date().toISOString();
            const existing = await get('bookings', `?select=id,property_id,platform,check_in,check_out,source_removed&check_in=gte.${nowIso}&source_removed=is.false`);
            const newKeys = new Set(finalRows.map(r=>`${r.property_id}|${r.platform}|${r.check_in}|${r.check_out}`));
            const toArchive = existing.filter(b=>!newKeys.has(`${b.property_id}|${b.platform}|${b.check_in}|${b.check_out}`)).map(b=>b.id);
            if (toArchive.length) {
              await patch('bookings', { source_removed: true }, `id=in.(${toArchive.join(',')})`);
            }

            console.log(JSON.stringify({
              feeds_processed: feeds.length,
              events_raw: rows.length,
              events_dedup: finalRows.length,
              bookings_soft_removed: toArchive.length
            }, null, 2));
          })().catch(e => { console.error('Fatal', e); process.exit(1); });
          EOF
